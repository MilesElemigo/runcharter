---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, echo = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/"
)
```

# runcharter <img src="man/figures/logo.png" width="160px" align="right" /> 


Automated analysis and re-basing of  run charts at scale.

Online documentation and vignettes : [runcharter](https://www.johnmackintosh.com/runcharter/)

[![Build Status](https://travis-ci.org/johnmackintosh/runcharter.svg?branch=master)](https://travis-ci.org/johnmackintosh/runcharter)
[![Project Status: WIP â€“ Initial development is in progress, but there has not yet been a stable, usable release suitable for the public.](https://www.repostatus.org/badges/latest/wip.svg)](https://www.repostatus.org/#wip)
[![Coverage status](https://codecov.io/gh/johnmackintosh/runcharter/branch/master/graph/badge.svg)](https://codecov.io/github/johnmackintosh/runcharter?branch=master)

## Installation

You can install runcharter from github with:

```{r gh-installation, eval = FALSE}
# install.packages("devtools")
devtools::install_github("johnmackintosh/runcharter")

# to ensure the vignettes are built or ensure latest version is installed:

devtools::install_github("johnmackintosh/runcharter", 
                         build_vignettes = TRUE, force = TRUE)
```

The rationale for the package is to analyse multiple run charts at once.
More importantly, the package will identify a run of n successive points on the desired side of the median line, and will recalculate / rebase the median accordingly.
Each time a run occurs, the median will be rebased.
This helps to track improvements over time. 


The default is to plot a faceted plot, allowing ggplot2 to handle the axis limits. 
You can specify the number of columns in the faceted plot, or let ggplot2 do its thing.



```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 6,
  fig.height = 5
)
```

Here are the function arguments and defaults. 
A default run of 9 is specified as that is the length of run used by the IHI for its patient safety initiatives worldwide. 

# Function arguments and defaults

```{r, eval=FALSE}

library(runcharter)
runcharter(df = signals,
          med_rows = 13,
          runlength = 9,
          direction = "below",
          datecol = NULL,
          grpvar = NULL,
          yval = NULL,
          facet_cols = NULL,
          chart_title = NULL,
          chart_subtitle = NULL,
          chart_caption = NULL,
          chart_breaks = NULL,
          line_colr = "#005EB8", # blue
          point_colr ="#005EB8", # blue
          median_colr = "#E87722", # orange
          sus_fill = "#DB1884") # magenta

```

The function will return a plot and a summary table showing the original baseline medians, and any sustained runs of improvement beyond the baseline period.


```{r}

library(runcharter)

runcharter(signals,
           direction = "below",
           datecol = "date", 
           grpvar = "grp",
           yval = "y", 
          chart_title = " Runs identified",
          chart_subtitle = "Runs below the median signalling improvement")

```



## Runs in both directions

Th package now allows for finding runs in both directions (above and below the median). 
Generally, for improvement purposes, you would only need to identify runs in one direction at a time. 
In other words, if you are trying to reduce adverse events, improvement will be evidenced with a run below the median. Therefore, you would not rebase the median if a run of points above the median was observed. 

However, for longer term monitoring, it may be necessary to identify and 'reset' a median if a sustained deterioration in performance occurs. Ideally, you should move to using SPC charts for monitoring purposes.

```{r}
library(runcharter)
signals %>% 
  runcharter(med_rows = 7, 
             runlength = 5,
             direction = "both",
             datecol = "date", 
              grpvar = "grp",
              yval = "y", 
             chart_title = "Runs in both directions",
             chart_subtitle = "Runs of 6, from median calculated over first 7 data points in each location")

```



## Design decisions and similar packages

This package makes no attempt to identify or highlight 'trends' (consecutively increasing or decreasing points) or shorter 'shifts' of runs below the median.
In 8 years of working with QI data, I very rarely see trends, and when they do appear, they tend to result after a period of process degradation, when the process begins to return back to its natural median state. 

In addition, [research by qicharts2 author Jacob Anheoj shows that the trend rule is not reliable](https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0121349). There are no plans to add tests to identify trends to the package functionality.

If you want to apply the rules for trend , in addition to rebasing run charts, then you should consider using [the runchart package by Joseph Adams](https://github.com/jsphdms/runchart).


[qicharts2](https://github.com/anhoej/qicharts2) creates run and SPC charts. These can be rebased, but you must specify when to do so. Also, the analysis is based on the author's own rules and not the rules typically used in healthcare (e.g. the rules promoted by the IHI).

## We're not supposed to do this

"But [insert QI expert name here] says you should not automatically rebase the median unless you know the signal is genuine".

Yes, and no. 

Truth is, sometimes, there is too much information being collected, or the task of manually performing this analysis is very time consuming, especially if you have to make manual adjustments to spreadsheets / databases / graphical outputs, to deadlines, whilst battling traditional BI tools that were only ever designed for bar and pie charts.
Ultimately, I built this for me, to make my job easier. 
I believe other healthcare analysts, who work with QI data, will also find it beneficial.

Obviously, there is no guarantee that any run that is identified is a genuine improvement. The user needs to verify this, however, the package aims to save time in identifying these signals in the first place. 

You can use the package to identify *potential* runs, and  if necessary, modify the outputs (e.g. the sustained dataframe) to remove any false signals, and rebuild the plot manually. 


## I don't like the final plot

You can use the package to do the analysis, take the outputs, and build your own plots.
Or save the output to a variable, retrieve the runchart component, and pass further ggplot2 syntax to amend it to your requirements.







